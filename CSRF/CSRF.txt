#################################Cross Site Request Forgery (CSRF)###########################################################


What is CSRF?
 Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they’re currently authenticated. With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker’s choosing. If the victim is a normal user, a successful CSRF attack can force the user to perform state changing requests like transferring funds, changing their email address, and so forth. If the victim is an administrative account, CSRF can compromise the entire web application.

----------------------------------------------------------------------------------------------------------------------------

How do we check if the website is vulnerable to CSRF?

CSRF is an attack that tricks the victim into submitting a malicious request. For most sites, browser requests automatically include any credentials associated with the site, such as user’s cookies. Therefore, if the user is currently authenticated to the site, the site will have no way to distinguish between the forged request sent by the victim and a legitimate request sent by the victim.

To understand how CSRF works, we need a tool to intercept Requests sent and their Responses. For this, we personally use Burpsuite.

Most of the times any POST request will contain 3 sections.

Header Section
Cookies section
Body parameters.
Nowadays, application security is all on a whole new level and there have been many proposals on how to stop CSRF attacks. The best option that has been implemented is the use of Anti-Csrf or X-Csrf-Token in the request.

Now, what is X-Csrf-Token?
Application developers nowadays add a pseudo-random token with either every request they sent or with every session in which the user is logged in. This token is used so that the application server can identify that this token has been generated by the user’s original request and not from a forged one.

There are 3 places where the developer can add the X-Csrf-Token.
Let us look at all the 3 scenarios one by one:

When the Anti-Csrf token is added to the Custom header:If the Anti-Csrf token is added as a custom header, the application is most probably not vulnerable to CSRF. Still, we can’t be sure just by that. So there are some other factors we need to check before confirming if the application is vulnerable to CSRF or not.
If the Anti-Csrf token is added in the Body parameter:If the developer chose to add the Anti-Csrf token in the body parameter field, in this case also the application has fewer chances of being vulnerable to CSRF like in case 1. The factors are the same as for case 1 which we will see later.
If the Anti-Csrf token is stored in the Cookie section:If any developer chose to add the token in cookies, in this case, the application has more chances of being vulnerable to CSRF. Now, why is that?
Cookies are local to a user machine. If a request is sent, no matter if the token gets changed with every request or session, if it is stored in a cookie, then the attacker won’t have to worry about the token since it will be added automatically with the forged request. The attacker won’t have to think about the algorithm of token generation because every time a request is sent to that website, the browser will make sure that the cookie is sent each time.
Ok, now we have gone through the cases where the Anti-Csrf token can be added. Now as we told before, the next part covers the different parameters we need to check additionally for getting sure of a CSRF vulnerability.

How to get sure of a CSRF vulnerability?
Case 1: Perform the request without modifying anything and see the Response.

Case 2: Remove CSRF token completely and see if the response is same as in case 1.

Case 3: Modify one of the characters in the token but keep the length the same. Compare the response with the response of case 1.

Case 4: Remove the value of the token but leave the parameter in place.
What happens is the developers know to add the token but sometimes they don’t do the validation properly.
If they don’t validate properly then it’s a matter of time that the attacker may do some brute forcing and come to know the logic behind the tokens.

Case 5: Change the POST request to a get request and see if it is then vulnerable to CSRF or not.

-----------------------------------------------------------------------------------------------------------------------------
References:

https://medium.com/@irounakdhadiwal999/how-to-perform-and-exploit-cross-site-request-forgery-csrf-attacks-1764c0f23585
https://owasp.org/www-community/attacks/csrf#:~:text=Cross%2DSite%20Request%20Forgery%20(CSRF,which%20they're%20currently%20authenticated.
https://portswigger.net/support/using-burp-to-test-for-cross-site-request-forgery
https://medium.com/@asfiyashaikh10/cross-site-request-forgery-csrf-8ce6f9ee0379


